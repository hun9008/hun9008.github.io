<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.9.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2024-02-16T23:53:52+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">console.log(‘HUN’)</title><subtitle>J.Y.Hun's Devlog</subtitle><author><name>Hun</name><email>younghune135@gmail.com</email></author><entry><title type="html">백준 동전 2 [c++]</title><link href="http://localhost:4000/2024/02/16/2294_coin2/" rel="alternate" type="text/html" title="백준 동전 2 [c++]" /><published>2024-02-16T15:18:00+09:00</published><updated>2024-02-16T15:28:25+09:00</updated><id>http://localhost:4000/2024/02/16/2294_coin2</id><content type="html" xml:base="http://localhost:4000/2024/02/16/2294_coin2/"><![CDATA[<h1 id="2294-동전-2-골드-5">2294 동전 2 골드 5</h1>

<h2 id="문제">문제</h2>
<p>n가지 종류의 동전이 있다. 이 동전들을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그러면서 동전의 개수가 최소가 되도록 하려고 한다. 각각의 동전은 몇 개라도 사용할 수 있다.</p>

<h2 id="입력">입력</h2>
<p>첫째 줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 동전의 가치는 100,000보다 작거나 같은 자연수이다. 가치가 같은 동전이 여러 번 주어질 수도 있다.</p>

<h2 id="출력">출력</h2>
<p>첫째 줄에 사용한 동전의 최소 개수를 출력한다. 불가능한 경우에는 -1을 출력한다.</p>

<h2 id="풀이">풀이</h2>

<p>동전1과 다르게 BFS로 풀어볼 수 있겠다고 생각되어 BFS로 풀어보려 했다.</p>

<p>처음에는 동전 종류를 큐에 넣고 하나씩 꺼내며 모든 종류의 동전을 더해가며 풀려했는데, 이러면 큐가 너무 많이 생겨 메모리 초과가 났다. (메모리 128MB 제한)</p>

<p>그래서 메모이제이션하면서 map배열에 index금액을 만드는데 든 동전 수를 저장하기로 함.</p>

<p>BFS를 사용하기 때문에(큐: 선입선출), 5원 3개를 쓴 경우가 (12원 1개, 1원 3개)를 쓴 경우보다 먼저 나오게 되어 최소값을 유지해줄 필요가 없다.</p>

<blockquote>
  <p>memset사용.</p>

  <p>처음 map을 (map[10001] = { -1, })로 초기화했는데, -1로 초기화 되지 않고 처음만 -1, 나머지는 0으로 초기화되었다.</p>

  <p>직접 초기화해주거나 memset을 사용해야겠다.</p>
</blockquote>

<h2 id="코드">코드</h2>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">coin</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">map</span><span class="p">[</span><span class="mi">10001</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">minUsed</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">bfs</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">coin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">){</span>
            <span class="n">map</span><span class="p">[</span><span class="n">coin</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">coin</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> 
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="c1">// cout &lt;&lt; "[" &lt;&lt; sum &lt;&lt; "]\n";</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        
        <span class="c1">// if(sum == k){</span>
        <span class="c1">//     if(used &lt; minUsed){</span>
        <span class="c1">//         minUsed = used;</span>
        <span class="c1">//     }</span>
        <span class="c1">// }</span>

        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">sum</span> <span class="o">+</span> <span class="n">coin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">10000</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="p">[</span><span class="n">sum</span> <span class="o">+</span> <span class="n">coin</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
                <span class="n">map</span><span class="p">[</span><span class="n">sum</span> <span class="o">+</span> <span class="n">coin</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">sum</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">sum</span> <span class="o">+</span> <span class="n">coin</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">k</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="n">coin</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">map</span><span class="p">));</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">coin</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">coin</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="n">bfs</span><span class="p">();</span>


    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">map</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name>Hun</name></author><category term="PS" /><category term="DP" /><category term="BFS" /><summary type="html"><![CDATA[2294 동전 2 골드 5]]></summary></entry><entry><title type="html">백준 트리_4803 [c++]</title><link href="http://localhost:4000/2024/02/16/4803_tree/" rel="alternate" type="text/html" title="백준 트리_4803 [c++]" /><published>2024-02-16T13:18:00+09:00</published><updated>2024-02-16T13:20:25+09:00</updated><id>http://localhost:4000/2024/02/16/4803_tree</id><content type="html" xml:base="http://localhost:4000/2024/02/16/4803_tree/"><![CDATA[<h1 id="4803-트리-골드-4">4803 트리 골드 4</h1>

<h2 id="문제">문제</h2>

<p>그래프는 정점과 간선으로 이루어져 있다. 두 정점 사이에 경로가 있다면, 두 정점은 연결되어 있다고 한다. 연결 요소는 모든 정점이 서로 연결되어 있는 정점의 부분집합이다. 그래프는 하나 또는 그 이상의 연결 요소로 이루어져 있다.</p>

<p>트리는 사이클이 없는 연결 요소이다. 트리에는 여러 성질이 있다. 예를 들어, 트리는 정점이 n개, 간선이 n-1개 있다. 또, 임의의 두 정점에 대해서 경로가 유일하다.</p>

<p>그래프가 주어졌을 때, 트리의 개수를 세는 프로그램을 작성하시오.</p>

<h2 id="입력">입력</h2>

<p>입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 n ≤ 500과 m ≤ n(n-1)/2을 만족하는 정점의 개수 n과 간선의 개수 m이 주어진다. 다음 m개의 줄에는 간선을 나타내는 두 개의 정수가 주어진다. 같은 간선은 여러 번 주어지지 않는다. 정점은 1번부터 n번까지 번호가 매겨져 있다. 입력의 마지막 줄에는 0이 두 개 주어진다.</p>

<h2 id="출력">출력</h2>

<p>입력으로 주어진 그래프에 트리가 없다면 “No trees.”를, 한 개라면 “There is one tree.”를, T개(T &gt; 1)라면 “A forest of T trees.”를 테스트 케이스 번호와 함께 출력한다.</p>

<h2 id="풀이">풀이</h2>

<p>그래프를 인접리스트로 vector를 이용해 입력받은 후 bfs를 돌면서 방문했던곳을 재방문했다면 cycle로 판단할 수 있다.</p>

<p>vector에는 인접한 정점들이 모두 저장되기에 bfs에서 now와 next의 pair를 이용해 직전 부모는 제외하고 탐색한다.</p>

<blockquote>
  <p>코드를 작성하고 제출했는데 테스트케이스는 모두 맞는데 틀렸다고 나왔다.
다른 코드들을 살펴보니 풀이방법, 코드도 거의 유사해 틀린부분을 찾기 힘들었는데,</p>

  <p>while문이 잘못되었었다.</p>

  <p>n과 m모두 0인 경우 종료해야한다.</p>

  <p>이 부분을 while(n != 0 &amp;&amp; m != 0)으로 작성했는데</p>

  <table>
    <tbody>
      <tr>
        <td>n과 m모두 0인 경우(n == 0 &amp;&amp; m == 0)의 반대는 =&gt; (n != 0</td>
        <td> </td>
        <td>m != 0) 이다.</td>
      </tr>
    </tbody>
  </table>

  <p>기본적인 건데 실수하지 말자..</p>
</blockquote>

<h2 id="코드">코드</h2>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">adj</span><span class="p">[</span><span class="mi">501</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">visited</span><span class="p">[</span><span class="mi">501</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">};</span>

<span class="kt">void</span> <span class="n">init</span><span class="p">(){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">501</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">bfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">){</span>

    <span class="kt">int</span> <span class="n">cycle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">now</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">first</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adj</span><span class="p">[</span><span class="n">now</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="n">adj</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span><span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">next</span><span class="p">]){</span>
                    <span class="n">cycle</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">else</span><span class="p">{</span>
                    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span> <span class="n">next</span><span class="p">,</span> <span class="n">now</span> <span class="p">));</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">cycle</span><span class="p">){</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span><span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">while</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">m</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>

        <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">tree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">from</span> <span class="o">&gt;&gt;</span> <span class="n">to</span><span class="p">;</span>
            <span class="n">adj</span><span class="p">[</span><span class="n">from</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">to</span><span class="p">);</span>
            <span class="n">adj</span><span class="p">[</span><span class="n">to</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// cout &lt;&lt; "input done\n";</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">bfs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
                    <span class="n">tree</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
		<span class="n">string</span> <span class="n">answer</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tree</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">answer</span> <span class="o">=</span> <span class="s">"No trees.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tree</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">answer</span> <span class="o">=</span> <span class="s">"There is one tree.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">answer</span> <span class="o">=</span> <span class="s">"A forest of "</span> <span class="o">+</span> <span class="n">to_string</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">+</span> <span class="s">" trees.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Case "</span> <span class="o">&lt;&lt;</span> <span class="n">cnt</span> <span class="o">&lt;&lt;</span> <span class="s">": "</span> <span class="o">&lt;&lt;</span> <span class="n">answer</span><span class="p">;</span>
        <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
        <span class="n">init</span><span class="p">();</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span></code></pre></figure>]]></content><author><name>Hun</name></author><category term="PS" /><category term="BFS" /><summary type="html"><![CDATA[4803 트리 골드 4]]></summary></entry><entry><title type="html">백준 숨바꼭질4 [c++]</title><link href="http://localhost:4000/2024/02/15/13913_%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%884/" rel="alternate" type="text/html" title="백준 숨바꼭질4 [c++]" /><published>2024-02-15T16:18:00+09:00</published><updated>2024-02-06T16:28:25+09:00</updated><id>http://localhost:4000/2024/02/15/13913_%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%884</id><content type="html" xml:base="http://localhost:4000/2024/02/15/13913_%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%884/"><![CDATA[<h1 id="13913-숨바꼭질4-골드-4">13913 숨바꼭질4 골드 4</h1>

<h2 id="문제">문제</h2>
<p>수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.</p>

<p>수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.</p>

<h2 id="입력">입력</h2>
<p>첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.</p>

<h2 id="출력">출력</h2>
<p>첫째 줄에 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.</p>

<p>둘째 줄에 어떻게 이동해야 하는지 공백으로 구분해 출력한다.</p>

<h2 id="풀이">풀이</h2>

<ul>
  <li>이전 숨바꼭질과 같이 BFS를 사용하는데 정답까지의 경로를 알아야 한다.</li>
  <li>경로를 저장하기 위해 parent배열을 만들어 queue에 입력될때마다 parent정보를 입력해준다.</li>
  <li>목적지에 도착하면 parent를 따라가며 출력한다.</li>
  <li>메모리 초과가 났는데 살펴보니 visited배열에 위치 int를 저장하고 있었다.(실수)</li>
  <li>이런 실수 안하게 애초에 visited는 bool로 선언하자.</li>
</ul>

<h2 id="코드">코드</h2>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">bool</span> <span class="n">visited</span><span class="p">[</span><span class="mi">100001</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">parent</span><span class="p">[</span><span class="mi">100001</span><span class="p">];</span>
<span class="n">queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">fast</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">bfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">first</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">sec</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="c1">// cout &lt;&lt; pos &lt;&lt; endl;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="n">k</span><span class="p">){</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sec</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="k">while</span><span class="p">(</span><span class="n">pos</span> <span class="o">!=</span> <span class="n">n</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">fast</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="n">fast</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
            <span class="n">reverse</span><span class="p">(</span><span class="n">fast</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">fast</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fast</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fast</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="mi">100000</span> <span class="o">&amp;&amp;</span> <span class="n">visited</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
            <span class="n">parent</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="mi">100000</span> <span class="o">&amp;&amp;</span> <span class="n">visited</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
            <span class="n">parent</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pos</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pos</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">100000</span> <span class="o">&amp;&amp;</span> <span class="n">visited</span><span class="p">[</span><span class="n">pos</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">pos</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
            <span class="n">parent</span><span class="p">[</span><span class="n">pos</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">pos</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">k</span><span class="p">;</span>

    <span class="n">bfs</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name>Hun</name></author><category term="PS" /><category term="BFS" /><summary type="html"><![CDATA[13913 숨바꼭질4 골드 4]]></summary></entry><entry><title type="html">백준 숨바꼭질3 [c++]</title><link href="http://localhost:4000/2024/02/15/13549_%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%883/" rel="alternate" type="text/html" title="백준 숨바꼭질3 [c++]" /><published>2024-02-15T15:18:00+09:00</published><updated>2024-02-15T15:20:25+09:00</updated><id>http://localhost:4000/2024/02/15/13549_%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%883</id><content type="html" xml:base="http://localhost:4000/2024/02/15/13549_%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%883/"><![CDATA[<h1 id="13549-숨바꼭질3-골드5">13549 숨바꼭질3 골드5</h1>

<h2 id="문제">문제</h2>
<p>수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 0초 후에 2*X의 위치로 이동하게 된다.</p>

<p>수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.</p>

<h2 id="입력">입력</h2>
<p>첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.</p>

<h2 id="출력">출력</h2>
<p>수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.</p>

<h2 id="풀이">풀이</h2>

<ul>
  <li>숨바꼭질1과 비슷한 형태이다.</li>
  <li>위치에서 -1, +1이 될 때는 1초가 걸리는데, *2를 할때는 0초가 걸리는 점을 고려해서 위치와 pair가 되는 sec을 설정해주면 된다.</li>
</ul>

<h2 id="코드">코드</h2>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">visited</span><span class="p">[</span><span class="mi">100001</span><span class="p">];</span>
<span class="n">queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">fast</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">bfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">first</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">sec</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="n">k</span><span class="p">){</span>
            <span class="n">fast</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">sec</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

        <span class="k">if</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="mi">100000</span> <span class="o">&amp;&amp;</span> <span class="n">visited</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="mi">100000</span> <span class="o">&amp;&amp;</span> <span class="n">visited</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pos</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pos</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">100000</span> <span class="o">&amp;&amp;</span> <span class="n">visited</span><span class="p">[</span><span class="n">pos</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">pos</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sec</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">}</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">k</span><span class="p">;</span>
    
    <span class="n">bfs</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">fast</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">fast</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fast</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name>Hun</name></author><category term="PS" /><category term="BFS" /><summary type="html"><![CDATA[13549 숨바꼭질3 골드5]]></summary></entry><entry><title type="html">백준 영역 구하기 [c++]</title><link href="http://localhost:4000/2024/02/15/2583_calArea/" rel="alternate" type="text/html" title="백준 영역 구하기 [c++]" /><published>2024-02-15T12:18:00+09:00</published><updated>2024-02-15T13:08:25+09:00</updated><id>http://localhost:4000/2024/02/15/2583_calArea</id><content type="html" xml:base="http://localhost:4000/2024/02/15/2583_calArea/"><![CDATA[<h1 id="2583-영역-구하기-실버-1">2583 영역 구하기 실버 1</h1>

<h2 id="문제">문제</h2>
<p>눈금의 간격이 1인 M×N(M,N≤100)크기의 모눈종이가 있다. 이 모눈종이 위에 눈금에 맞추어 K개의 직사각형을 그릴 때, 이들 K개의 직사각형의 내부를 제외한 나머지 부분이 몇 개의 분리된 영역으로 나누어진다.</p>

<p>예를 들어 M=5, N=7 인 모눈종이 위에 &lt;그림 1&gt;과 같이 직사각형 3개를 그렸다면, 그 나머지 영역은 &lt;그림 2&gt;와 같이 3개의 분리된 영역으로 나누어지게 된다.</p>

<p>&lt;그림 2&gt;와 같이 분리된 세 영역의 넓이는 각각 1, 7, 13이 된다.</p>

<p>M, N과 K 그리고 K개의 직사각형의 좌표가 주어질 때, K개의 직사각형 내부를 제외한 나머지 부분이 몇 개의 분리된 영역으로 나누어지는지, 그리고 분리된 각 영역의 넓이가 얼마인지를 구하여 이를 출력하는 프로그램을 작성하시오.</p>

<h2 id="입력">입력</h2>
<p>첫째 줄에 M과 N, 그리고 K가 빈칸을 사이에 두고 차례로 주어진다. M, N, K는 모두 100 이하의 자연수이다. 둘째 줄부터 K개의 줄에는 한 줄에 하나씩 직사각형의 왼쪽 아래 꼭짓점의 x, y좌표값과 오른쪽 위 꼭짓점의 x, y좌표값이 빈칸을 사이에 두고 차례로 주어진다. 모눈종이의 왼쪽 아래 꼭짓점의 좌표는 (0,0)이고, 오른쪽 위 꼭짓점의 좌표는(N,M)이다. 입력되는 K개의 직사각형들이 모눈종이 전체를 채우는 경우는 없다.</p>

<h2 id="출력">출력</h2>
<p>첫째 줄에 분리되어 나누어지는 영역의 개수를 출력한다. 둘째 줄에는 각 영역의 넓이를 오름차순으로 정렬하여 빈칸을 사이에 두고 출력한다.</p>

<h2 id="풀이">풀이</h2>
<ul>
  <li>입력으로 받는 두 좌표에 해당하는 영역을 visited = 1로 설정해주고 bfs를 진행했다.</li>
  <li>(0,0)이 좌측 하단에 위치해 영역이 상하반전 되어있음에 주의해야 함.</li>
  <li>BFS에서 x와 y의 좌표에 주의하면 일반적인 BFS문제.</li>
</ul>

<h2 id="코드">코드</h2>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">visited</span><span class="p">[</span><span class="mi">101</span><span class="p">][</span><span class="mi">101</span><span class="p">];</span>

<span class="kt">int</span> <span class="n">dir</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">}};</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">area</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">init</span><span class="p">(){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">101</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">101</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">sq</span><span class="p">(</span><span class="kt">int</span> <span class="n">LX</span><span class="p">,</span> <span class="kt">int</span> <span class="n">LY</span><span class="p">,</span> <span class="kt">int</span> <span class="n">RX</span><span class="p">,</span> <span class="kt">int</span> <span class="n">RY</span><span class="p">){</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">LY</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RY</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">LX</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">RX</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">bfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">a1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b1</span><span class="p">){</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">));</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">a1</span><span class="p">][</span><span class="n">b1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">first</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
 
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="kt">int</span> <span class="n">n_x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dir</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">n_y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dir</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">n_x</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">n_x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">n_y</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">n_y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">n_y</span><span class="p">][</span><span class="n">n_x</span><span class="p">]){</span>
                    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">n_y</span><span class="p">,</span> <span class="n">n_x</span><span class="p">));</span>
                    <span class="n">visited</span><span class="p">[</span><span class="n">n_y</span><span class="p">][</span><span class="n">n_x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                    <span class="n">size</span><span class="o">++</span><span class="p">;</span> <span class="c1">//영역넓이 + 1</span>
                <span class="p">}</span>
            <span class="p">}</span> 
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">area</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">print_visit</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">init</span><span class="p">();</span>

    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">m</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">k</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">lx</span><span class="p">,</span><span class="n">ly</span><span class="p">,</span><span class="n">rx</span><span class="p">,</span><span class="n">ry</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">lx</span> <span class="o">&gt;&gt;</span> <span class="n">ly</span> <span class="o">&gt;&gt;</span> <span class="n">rx</span> <span class="o">&gt;&gt;</span> <span class="n">ry</span><span class="p">;</span>
        <span class="n">sq</span><span class="p">(</span><span class="n">lx</span><span class="p">,</span> <span class="n">ly</span><span class="p">,</span> <span class="n">rx</span><span class="p">,</span> <span class="n">ry</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// print_visit();</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
                <span class="c1">// cout &lt;&lt; "pos" &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; endl;</span>
                <span class="n">bfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>
                <span class="c1">// print_visit();</span>
                <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">cnt</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">area</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">area</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">area</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">area</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name>Hun</name></author><category term="PS" /><category term="BFS" /><summary type="html"><![CDATA[2583 영역 구하기 실버 1]]></summary></entry><entry><title type="html">백준 숨바꼭질2 [c++]</title><link href="http://localhost:4000/2024/02/15/12851_%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%882/" rel="alternate" type="text/html" title="백준 숨바꼭질2 [c++]" /><published>2024-02-15T12:18:00+09:00</published><updated>2024-02-15T13:08:25+09:00</updated><id>http://localhost:4000/2024/02/15/12851_%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%882</id><content type="html" xml:base="http://localhost:4000/2024/02/15/12851_%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%882/"><![CDATA[<h1 id="12851-숨바꼭질2-골드-4">12851 숨바꼭질2 골드 4</h1>

<h2 id="문제">문제</h2>

<p>수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.</p>

<p>수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 그리고, 가장 빠른 시간으로 찾는 방법이 몇 가지 인지 구하는 프로그램을 작성하시오.</p>

<h2 id="입력">입력</h2>
<p>첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.</p>

<h2 id="출력">출력</h2>
<p>첫째 줄에 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.</p>

<p>둘째 줄에는 가장 빠른 시간으로 수빈이가 동생을 찾는 방법의 수를 출력한다.</p>

<h2 id="풀이">풀이</h2>

<p>BFS로 queue에 위치(pos)와 움직인 수(move)를 pair로 저장해서 해결하려 했다.</p>

<p>숨바꼭질1 과 달리 최소도달횟수가 몇가지인지도 출력해야 한다. 그래서 동생에게 도달한 경우를 모두 vector에 저장하고
BFS가 종료된 후, vector를 정렬해 최소도달횟수가 몇개인지 따로 찾았다.</p>

<h2 id="코드">코드</h2>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">visited</span><span class="p">[</span><span class="mi">100001</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">minM</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">findM</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">bfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">first</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">move</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>
        <span class="c1">// cout &lt;&lt; pos &lt;&lt; endl;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="n">k</span><span class="p">){</span>
            <span class="n">findM</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">move</span><span class="p">);</span>
            <span class="c1">// if(move &lt;= minM){</span>
            <span class="c1">//     minM = move;</span>
            <span class="c1">// }else{</span>
            <span class="c1">//     q.pop();</span>
            <span class="c1">//     continue;</span>
            <span class="c1">// }</span>
        <span class="p">}</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">nPos</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pos</span> <span class="o">*</span> <span class="mi">2</span><span class="p">};</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">nPos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nPos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">100000</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">nPos</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
                    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">nPos</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">move</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
                    
                <span class="p">}</span>
            <span class="p">}</span>   
        <span class="p">}</span>

    <span class="p">}</span>   
    
<span class="p">}</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">k</span><span class="p">;</span>

    <span class="n">bfs</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">findM</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">findM</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

    <span class="c1">// for(int i = 0; i &lt; findM.size(); i++)</span>
    <span class="c1">// {</span>
    <span class="c1">//     cout &lt;&lt; findM[i] &lt;&lt; " ";</span>
    <span class="c1">// }</span>

    <span class="kt">int</span> <span class="n">wayM</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">findM</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">findM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">findM</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span>
            <span class="n">wayM</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">findM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">wayM</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name>Hun</name></author><category term="PS" /><category term="BFS" /><summary type="html"><![CDATA[12851 숨바꼭질2 골드 4]]></summary></entry><entry><title type="html">Going Deeper with convolutions [논문]</title><link href="http://localhost:4000/2024/02/15/GoingDeeperWithConvolutions/" rel="alternate" type="text/html" title="Going Deeper with convolutions [논문]" /><published>2024-02-15T01:18:00+09:00</published><updated>2024-02-15T02:08:25+09:00</updated><id>http://localhost:4000/2024/02/15/GoingDeeperWithConvolutions</id><content type="html" xml:base="http://localhost:4000/2024/02/15/GoingDeeperWithConvolutions/"><![CDATA[<p>저자 : Christian Szegedy 등등</p>

<h2 id="introduction">Introduction</h2>

<p>GoogLeNet의 특징</p>
<ul>
  <li>연산을 하는 데 소모되는 자원의 사용 효율이 개선되었다.</li>
  <li>Inception은 GoogLeNet의 코드네임.</li>
</ul>

<p>딥러닝의 발전 동향이 더 좋은 하드웨어의 성능, 더 큰 dataset, 더 큰 모델 때문이기 보다는 새로운 아이디어와 알고리즘, 그리고 개선된 신경망 구조 덕분이다라고 언급.</p>

<p>GoogLeNet은 AlexNet보다 파라미터가 12배나 더 적음에도 불구하고 훨씬 정확했다고 함. 이런 개선은 R-CNN과 같이 deep한 구조와 클래식한 컴퓨터 비전의 시너지 덕분이다.</p>

<p>Mobile 및 Embedded 환경에서는 특히 전력 및 메모리 사용량 관점에서 효율적인 알고리즘의 중요성이 대두되고 있기에, 이 논문에서는 모델이 엄격한 고정된 구조를 가지는 것보다 유연한 구조를 가지게끔 한다. 또한 추론 시간에 1.5B 이하의 연산만을 수행하도록 설계했다.</p>

<p>GoogLeNet의 코드네임인 Inception은 영화 인셉션에 “we need to go deeper”에서 유래했고 여기서 deep은 두가지 의미를 가짐.</p>
<ol>
  <li>“Inception module”의 형태로 새로운 차원의 구조 도입</li>
  <li>두 번째는 네트워크의 깊이가 증가하였다는 직접적인 의미</li>
</ol>

<h2 id="related-work">Related Work</h2>

<p>LeNet-5을 시작으로 CNN은 일반적인 표준 구조를 가지는데, Convolutional layer가 쌓이고 그 뒤에 1개 또는 그 이상의 FC layer가 따라오는 구조이다. 또한 대용량 데이터에서 layer 수와 사이즈를 늘리고, overfitting을 피하기 위해 dropout을 적용한다.</p>

<p>GoogLeNet도 이와 같은 구조를 가진다.</p>

<p>Network-in-Network : 1 X 1 Convolutional layer를 사용해 네트워크의 표현력을 증가시키고 계산 효율성을 높이는 접근 방법이다.
이 방법은 1 X 1 Convolutional layer가 추가되며, ReLU activation이 뒤따른다.</p>

<p>이때, 1 X 1 Convolutional layer의 목적은 2가지로 이 이유로 GoogLeNet에서 사용된다.</p>

<ol>
  <li>병목현상을 제거하기 위한 차원 축소</li>
  <li>네트워크 크기 제안한다</li>
</ol>

<details>
<summary>
Network-in-Network에서는 왜 1 X 1 Convolutional layer를 사용했고, 이는 어떻게 위 두가지 장점을 가지게 되는가?
</summary>

<br />
<img src="/GoogLeNet_11Convolution.png" />

NIN(Network-in-Network)에서는 CCCP(Casecaded Cross Channel Pooling)이란 기법이 사용되었다. <br />이는 하나의 feature map에 대해 수행하는 일반적인 pooling 기법과 달리 channel을 직렬로 묶어 픽셀 별로 pooling을 수행하는 것으로, feature map의 크기는 그대로이고, channel의 수만 줄어들게 하여 차원 축소의 효과가 있다. 
<br /><br />
CCCP 작동 방식:
<br /><br />
1. 채널 직렬 연결: 먼저, 서로 연관성이 높은 채널들을 그룹화하여 직렬로 연결합니다.<br />
2. 픽셀별 풀링: 각 채널 그룹에 대해 픽셀별 최대 풀링 또는 평균 풀링을 수행합니다.<br />
3. 채널 축소: 풀링 결과를 통해 채널 수를 줄여 계산 효율성을 높입니다.(3D -&gt; 1D)<br />
4. 다단계 풀링: 위의 과정을 여러 단계 반복하여 더욱 강력한 특징 추출을 수행합니다.<br /><br />

그런데 이 CCCP 기법은 1 x 1 Convolutional layer과 그 연산 방식 및 효과가 매우 유사하다. 따라서 GoogLeNet에서 1 x 1 Convolutional layer를 Inception module에 적용한 것이다.
</details>

<h2 id="motivation-and-high-level-considerations">Motivation and High Level Considerations</h2>]]></content><author><name>Hun</name></author><category term="Paper" /><category term="GoogLeNet" /><category term="Inception" /><summary type="html"><![CDATA[저자 : Christian Szegedy 등등]]></summary></entry><entry><title type="html">백준 점프 [c++]</title><link href="http://localhost:4000/2024/02/09/1890_Jump/" rel="alternate" type="text/html" title="백준 점프 [c++]" /><published>2024-02-09T16:00:00+09:00</published><updated>2024-02-09T17:08:25+09:00</updated><id>http://localhost:4000/2024/02/09/1890_Jump</id><content type="html" xml:base="http://localhost:4000/2024/02/09/1890_Jump/"><![CDATA[<h1 id="1890-점프-실버-1">1890 점프 실버 1</h1>

<h2 id="문제">문제</h2>

<p>N×N 게임판에 수가 적혀져 있다. 이 게임의 목표는 가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 규칙에 맞게 점프를 해서 가는 것이다.</p>

<p>각 칸에 적혀있는 수는 현재 칸에서 갈 수 있는 거리를 의미한다. 반드시 오른쪽이나 아래쪽으로만 이동해야 한다. 0은 더 이상 진행을 막는 종착점이며, 항상 현재 칸에 적혀있는 수만큼 오른쪽이나 아래로 가야 한다. 한 번 점프를 할 때, 방향을 바꾸면 안 된다. 즉, 한 칸에서 오른쪽으로 점프를 하거나, 아래로 점프를 하는 두 경우만 존재한다.</p>

<p>가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 규칙에 맞게 이동할 수 있는 경로의 개수를 구하는 프로그램을 작성하시오.</p>

<h2 id="입력">입력</h2>

<p>첫째 줄에 게임 판의 크기 N (4 ≤ N ≤ 100)이 주어진다. 그 다음 N개 줄에는 각 칸에 적혀져 있는 수가 N개씩 주어진다. 칸에 적혀있는 수는 0보다 크거나 같고, 9보다 작거나 같은 정수이며, 가장 오른쪽 아래 칸에는 항상 0이 주어진다.</p>

<h2 id="출력">출력</h2>
<p>가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 문제의 규칙에 맞게 갈 수 있는 경로의 개수를 출력한다. 경로의 개수는 263-1보다 작거나 같다.</p>

<h2 id="풀이">풀이</h2>
<p>처음에 그래프 문제라 생각하고 BFS로 풀면 되겠다 생각했다.</p>

<h2 id="bfs-코드">BFS 코드</h2>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">visited</span><span class="p">[</span><span class="mi">101</span><span class="p">][</span><span class="mi">101</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">maze</span><span class="p">[</span><span class="mi">101</span><span class="p">][</span><span class="mi">101</span><span class="p">];</span>
<span class="n">queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">init</span><span class="p">(){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">101</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">101</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">bfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>

    <span class="n">visited</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">maze</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">));</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">maze</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]));</span>

    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
        <span class="kt">int</span> <span class="n">posX</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">first</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">posY</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>
        <span class="c1">// if(posX == n-1 &amp;&amp; posY == n-1){</span>
        <span class="c1">//     cnt++;</span>
        <span class="c1">//     q.pop();</span>
        <span class="c1">//     continue;</span>
        <span class="c1">// }</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">posX</span><span class="p">][</span><span class="n">posY</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">nX</span> <span class="o">=</span> <span class="n">posX</span> <span class="o">+</span> <span class="n">maze</span><span class="p">[</span><span class="n">posX</span><span class="p">][</span><span class="n">posY</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">nY</span> <span class="o">=</span> <span class="n">posY</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">nX</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">nY</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">){</span>
            <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">nX</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">){</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">nX</span><span class="p">,</span> <span class="n">nY</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="n">nX</span> <span class="o">=</span> <span class="n">posX</span><span class="p">;</span>
        <span class="n">nY</span> <span class="o">=</span> <span class="n">posY</span> <span class="o">+</span> <span class="n">maze</span><span class="p">[</span><span class="n">posX</span><span class="p">][</span><span class="n">posY</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="n">nX</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">nY</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">){</span>
            <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">nY</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">){</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">nX</span><span class="p">,</span> <span class="n">nY</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>

    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">maze</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">init</span><span class="p">();</span>
    <span class="n">bfs</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">cnt</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>BFS로 풀었더니, 메모리 초과가 났다. 다른 풀이를 찾아보니 다들 DP로 해결했었다. 이유를 보니 중복을 허용해야 하고 경우의 수가 많아져 시간초과 또는 메모리 초과가 나 그래프로는 풀기 적합하지 않다는 것을 알게 되었다.</p>

<p>이후 DP로 다시 접근했다.</p>

<p>2차원 영역에서 진행하는 방향은 우측하단으로 정해져있기 때문에 이중 반복문으로 탐색해나가도 된다.</p>

<ul>
  <li>처음 dp[0][0]은 1로 설정한다. (시작점에서 시작점까지 가는 경우는 1)</li>
  <li>우측 그리고 아래 방향으로 갈 수 있다면 이동할 dp값을 지금위치의 dp값만큼 더한다.
    <ul>
      <li>https://sdev.tistory.com/992</li>
    </ul>
  </li>
</ul>

<h2 id="dp-코드">DP 코드</h2>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">long</span> <span class="kt">long</span> <span class="n">dp</span><span class="p">[</span><span class="mi">101</span><span class="p">][</span><span class="mi">101</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">maze</span><span class="p">[</span><span class="mi">101</span><span class="p">][</span><span class="mi">101</span><span class="p">];</span>


<span class="kt">void</span> <span class="nf">init</span><span class="p">(){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">101</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">101</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>

    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">maze</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">init</span><span class="p">();</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">move</span> <span class="o">=</span> <span class="n">maze</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="k">if</span><span class="p">(</span><span class="n">move</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">move</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">){</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">move</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="n">move</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">){</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="n">move</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name>Hun</name></author><category term="PS" /><category term="DP" /><category term="BFS" /><summary type="html"><![CDATA[1890 점프 실버 1]]></summary></entry><entry><title type="html">FixBi-Bridging Domain Spaces for Unsupervised Domain Adaptation [논문]</title><link href="http://localhost:4000/2024/02/08/BridgingDomainSpacesForUnsupervisedDomainAdaptation/" rel="alternate" type="text/html" title="FixBi-Bridging Domain Spaces for Unsupervised Domain Adaptation [논문]" /><published>2024-02-08T21:18:00+09:00</published><updated>2024-02-13T21:18:25+09:00</updated><id>http://localhost:4000/2024/02/08/BridgingDomainSpacesForUnsupervisedDomainAdaptation</id><content type="html" xml:base="http://localhost:4000/2024/02/08/BridgingDomainSpacesForUnsupervisedDomainAdaptation/"><![CDATA[<p>저자 : Wonjun Hwang</p>

<h2 id="1-introduction">1. Introduction</h2>
<p>최근 컴퓨터 비전 딥러닝 애플리케이션에서 상당한 개선을 보였지만, 대부분 지도학습이었다. 지도학습에는 데이터를 수입하는데 많은 비용이 들어 준지도(semi-supervised), 비지도(unsupervised)학습이 연구되었는데 이는 유사한 도메인에서의 학습이었다.</p>

<p><img src="/UDA_figure1.png" /></p>

<blockquote>
  <p>이전 UDA에서는 source와 target 도메인의 격차를 줄이기 위해 discriminator(판별자), MMD, JMMD 등을 사용했고 GAN 기반 DA가 사용되었다. 기본적으로 이는 source와 target간의 거리가 큰 경우는 고려되지 않는다.</p>
</blockquote>

<p>이 논문에서는 큰 도메인 불일치를 효율적으로 보상하기 위해 서로 상보적인 중간 증강 도메인을 구성한다. 이를 위해 Fixed ratio based mixup을 제안한다.</p>

<p>Fixed ratio based mixup은 source와 target사이 무작위성을 최소화하고 여러 중간 도메인을 생성한다.</p>
<blockquote>
  <p>예를들어 Augmented domain close to the source domain 은 레이블 정보는 있지만 target 도메인과 상관관계는 낮다.</p>

  <p>반면 Augmented domain close to the target domain은 라벨 정보는 부정확하지만 target domain과 유사성은 높다.</p>
</blockquote>

<p>이런 증강된 도메인에서 source와 target 도메인 사이를 연결하도록 서로 가르치는 보완모델을 훈련한다.
구체적으로, target 샘플에 대한 높은 신뢰도 예측을 기반으로 한 양방향 매칭을 도입해 중간 도메인을 target 도메인으로 연결시킨다.</p>

<p>또한 self-traning을 통해 성능을 향상시키기 위해, self-penalization을 적용한다.</p>

<p>또한 각 iteration마다 변화하는 특성을 적절히 부과하가 위해 각 미니배치의 신뢰분포에 의한 적응형 임계값을 사용한다.</p>

<p>마지막으로 서로 다른 증강된 모델의 발산을 막고자, source와 target 샘플의 비율이 동일한 증강 도메인을 사용해 일관성 정규화를 제안한다.</p>

<p>Office-31, Office-Home, VisDA에서 테스트를 수행했다.</p>

<h2 id="2-related-work">2. Related Work</h2>

<p>semi supervised learning(준지도 학습)</p>
<ul>
  <li>레이블 부족 문제 개선</li>
  <li>데이터 증강 기반 최근 연구 활발 (MixMatch, FixMatch, ReMixMatch 등)
    <blockquote>
      <p>MixMatch: 데이터 증강, 엔트로피 최소화</p>

      <p>FixMatch: 일관성 정규화, 의사 레이블, 강화된 증강</p>

      <p>ReMixMatch: MixMatch + FixMatch + 분포 일치 손실 + 자동 증강</p>
    </blockquote>
  </li>
  <li>주로 레이블/레이블되지 않은 데이터가 유사 도메인 가정</li>
</ul>

<p>SSDA(semi supervised domain adaptation)에 비해 UDA는 더 많은 target lable의 정보를 가지고 있다.</p>
<blockquote>
  <p>semi supervised의 신호를 활용한 연구</p>

  <p>[Semi-supervised domain adaptation via minimax entropy] : 적응적 few-shot 모델 최적화를 위한 minimax 엔트로피 접근
[Opposite structure learning for semi-supervised domain adaptation] : 생성기와 두 개의 분류기를 이용하여 반대 구조 학습 통합</p>
</blockquote>

<p>[Mixup co-training for semi-supervised domain adaptation. - 44] 과 본 논문 비교.</p>
<ul>
  <li>[44]에서는 SSDA를 SSL과 UDA로 분류하여 해결하고자 함.</li>
  <li>두 가지 모델이 각 하위 문제를 담당하며 co-training 기반으로 학습.</li>
  <li>한 모델은 labeled source sample 과 labeled target sample로 훈련됨.</li>
  <li>다른 한 모델은 unlabeled target sample과 labeled target sample로 훈련됨.</li>
</ul>

<p>반면 ([44]와 다르게) 이 논문에서는 양방향 매칭을 통해 target 도메인의 의사 레이블을 훈련한다. 또한 [44]에서는 일부 target sample을 선택 사용하지만 본 논문에서는 모든 target sample을 사용한다.</p>

<p>최근 여러 연구에서는 도메인 정렬 및 차별적인 도메인 불변적 특성 학습 방법을 기반으로 UDA에 중점을 두고 있다.</p>

<ul>
  <li>Deep Adaptation Network(DAN)은 도메인 특정 계층에 대한 MMD를 최소화하고 Joint Adaptation Network는 JMMD를 기반으로 여러 도메인에 걸쳐 도메인 특정 레이어의 공동 분포를 정렬했습니다.</li>
  <li>Deep Domain Confusion(DDC)는 discriminative 도메인과 transferable 도메인을 모두 학습시키기 위해 fully connected layer에서 MMD metric을 사용했다.</li>
  <li>Domain Adversarial Neural Network(DANN)은 도메인 분류기의 reverse gradients를 back-propagating해 도메인 불변 표현을 학습했다.</li>
  <li>Adversarial Discriminative Domain Adaptation(ADDA)는 source label을 사용하여 판별적 표현을 학습한 후 도메인-적대 손실을 기반으로 대상 데이터를 동일한 공간에 매핑하는 별도의 인코딩을 사용한다.</li>
  <li>Maximum classification discrepancy(MCD)는 대상 샘플의 불일치를 최대화한 다음 이 불일치를 최소화하는 기능을 생성하여 작업별 결정 경계를 고려하여 대상 도메인의 분포를 정렬하려고 했다.</li>
  <li>Contrastive adaptation network(CAN)는 클래스 내 도메인 불일치와 클래스 간 도메인 불일치를 명시적으로 모델링하는 도메인 불일치를 최소화하기 위한 metric을 최적화했다.</li>
  <li>Robust spherical domain adaptation(RSDA)는 구형 분류기와 구형 도메인 구별기를 사용하여 레이블 예측과 도메인 구별을 수행하며, 구형 특징 공간에서 강인한 의사 레이블 손실을 활용한다.</li>
  <li>Structurally regularized deep clustering(SRDC) 중간 네트워크 특징을 군집화하고 source example 선택의 구조적 정규화를 통해 target 식별을 개선합니다.</li>
  <li>Dual mixup regularized learning(DMRL) 샘플 간 일관적인 예측 향상과 잠재 공간의 내재 구조 강화를 위해 분류기를 유도합니다. 소스와 타겟 도메인 혼합을 위해 랜덤성 기반 믹스업 정규화 두 가지를 제안합니다.</li>
</ul>

<p>본 연구에서는 기존 연구 ([41, 43] 등)과 달리 랜덤성에만 의존하여 증강 도메인을 생성하지 않는다. 대신 두 개의 Fixed ratio mixup을 사용해 두 가지 증강 도메인을 생성한다.</p>

<ol>
  <li>source closed augmented domain : 명확한 label 존재, target domain과는 거리가 있음.</li>
  <li>target closed augmented domain : target domain 특성 존재, source domain과는 거리가 있음.</li>
</ol>

<p>서로 다른 특징을 가진 두 증강 도메인을 사용하여 서로 “가르치는” 방식으로 학습
이를 통해 도메인 지식을 타겟 도메인으로 효과적으로 전달</p>

<h2 id="3-proposed-methods">3. Proposed methods</h2>

<p>UDA에서는 source 도메인으로부터 label이 지정된 데이터 
\( X^{s} = {(x_i^s, y_i^s)}^{N_s}_{i=1}\) 가 주어지고,</p>

<p>target 도메인으로부터 label이 지정되지 않은 데이터
\( X^{t} = {(x_i^t)}^{N_t}_{i=1}\) 가 주어진다.</p>

<p>Ns와 Nt는 각각 Xs와 Xt의 크기를 나타낸다.
이 논문의 목표는 source 도메인에서 학습한 지식이 target 도메인에서 잘 일반화되도록 하는 것이다.</p>

<p><img src="/UDA_figure2.png" /></p>

<h3 id="31-fixed-ratio-based-mixup">3.1 Fixed Ratio-based Mixup</h3>
<p>기존 믹스업의 문제점:</p>

<ul>
  <li>기존 믹스업에서는 랜덤하게 생성된 비율로 source 데이터와 target 데이터를 혼합하여 가상 샘플을 생성한다.</li>
  <li>이는 도메인 간 격차를 고려하지 않고 가상 샘플을 만드기 때문에 모델 성능 향상에 한계가 있다.</li>
</ul>

<p>제안된 고정 비율 믹스업:</p>

<ul>
  <li>본 논문에서는 랜덤 비율 대신 <strong>고정 비율 (λsd, λtd)</strong>을 사용하여 가상 샘플을 생성한다.</li>
  <li>이 고정 비율은 source 데이터와 target 데이터의 중요도를 반영한다.</li>
  <li>또한 두 개의 다른 믹스업 비율을 사용하여 <strong>source 우세 모델 (SDM)</strong>과 <strong>target 우세 모델 (TDM)</strong>이라는 두 가지 네트워크를 생성한다.</li>
  <li>SDM은 source 데이터에 더 강한 영향을 받아 학습되고, TDM은 target 데이터에 더 강한 영향을 받아 학습된다.</li>
</ul>

<p>입력 샘플 쌍과 source 및 target 도메인의 해당 one-hot labels\( (x^s_i, y_i^s) \)이 주어지면 mixup setting은 다음과 같이 정의됩니다:</p>

\[\widetilde{x}^{st}_i = \lambda x^{s}_i + (1-\lambda)x^{t}_i\]

\[\widetilde{y}^{st}_i = \lambda y^{s}_i + (1-\lambda)\hat{y}^{t}_i\]

<p>그리고 \(p(y\| \widetilde{x}^{st}_i)\)를 입력 \(\widetilde{x}^{st}_i\)에 대한 모델에 의해 생성된 예측된 클래스 분포라고 하자. 그러면 fixed ratio-based mixip은 다음과 같이 정의된다.</p>

\[L_{fm} = \frac{1}{B} \sum_{i=1}^{B} \widetilde{y}^{st}_i log(p(y\\| \widetilde{x}^{st}_i))\]

<h3 id="32-confidence-based-learning">3.2 Confidence-based learning</h3>

<p>상호 보완 학습:</p>

<ul>
  <li>고정 비율 믹스업으로 생성된 두 모델은 서로 다른 특징을 가지고 학습된다.</li>
  <li>이러한 서로 다른 특징은 서로 보완적인 학습을 가능하게 한다.</li>
</ul>

<p>신뢰도 기반 학습:</p>

<ul>
  <li>한 모델은 긍정적 의사 라벨을 사용하여 다른 모델을 가르치고, 부정적 의사 라벨을 사용하여 자기 자신을 학습한다.</li>
</ul>

<p>양방향 매칭:</p>

<ul>
  <li>모델 중 하나가 특정 임계값 이상의 확률로 클래스를 예측하면 이를 긍정적 의사 라벨로 사용한다.</li>
  <li>긍정적 의사 라벨을 이용하여 서로 다른 모델의 예측이 일치하도록 학습한다.</li>
</ul>

\[L_{bim} = \frac{1}{B} \sum_{i=1}^{B} max(p(y\\| \widetilde{x}^{t}_i)&gt;\tau) \widetilde{y}^{t}_i log(q(y\\| x^{t}_i))\]

<p>self penalization:</p>

<ul>
  <li>부정적 의사 라벨 (확률 낮은 최고 예측 클래스)을 사용하여 각 모델이 예측 오류를 줄이도록 학습한다.</li>
</ul>

\[L_{sp} = \frac{1}{B} \sum_{i=1}^{B} max(p(y\\| \widetilde{x}^{t}_i)&gt;\tau) \widetilde{y}^{t}_i log(1 - p(y\\| x^{t}_i))\]

<p>낮은 확률 예측 활용:</p>

<ul>
  <li>일반적으로 낮은 확률 예측은 신뢰성이 낮으나, 이 논문에서는 이러한 예측도 학습에 활용한다.</li>
</ul>

<p>적응적 임계값:</p>

<ul>
  <li>긍정적/부정적 의사 라벨을 구분하는 임계값을 고정 값 대신 미니배치 데이터의 평균과 표준편차를 이용하여 동적으로 조정한다.</li>
</ul>

<h3 id="33-consistency-regularization">3.3 Consistency Regularization</h3>

<p>신뢰도 기반 학습을 통해 더 정확한 의사 라벨을 가지고 학습함으로써 두 모델이 target 영역에 더 가까워진다.
새로운 일치성 정규화는 두 모델 모두 안정적으로 수렴하도록 한다.
잘 학습된 모델은 같은 공간에서 일관된 결과를 보여야 한다는 가정을 기반으로 한다.
이는 서로 다른 도메인에서 학습된 두 모델이 source와 target 도메인 사이의 중간 공간에서 일관성을 유지하도록 하여 도메인 간 연결을 구축한다.
중간 공간에서는 고정 믹스업 비율 λsd와 λtd가 모두 0.5로 설정된다.
일치성 정규화 손실 함수는 다음과 같이 정의된다.</p>

\[L_{cr} = \frac{1}{B} \sum_{i=1}^{B} || p(y\\| \widetilde{x}^{st}_i) - q(y\\| \widetilde{x}^{st}_i) ||^{2}_2\]]]></content><author><name>Hun</name></author><category term="Paper" /><category term="Domain Adaptation" /><summary type="html"><![CDATA[저자 : Wonjun Hwang]]></summary></entry><entry><title type="html">백준 트리의 지름(1167) [c++]</title><link href="http://localhost:4000/2024/02/08/1167_TreeRadius/" rel="alternate" type="text/html" title="백준 트리의 지름(1167) [c++]" /><published>2024-02-08T20:00:00+09:00</published><updated>2024-02-08T20:08:25+09:00</updated><id>http://localhost:4000/2024/02/08/1167_TreeRadius</id><content type="html" xml:base="http://localhost:4000/2024/02/08/1167_TreeRadius/"><![CDATA[<h1 id="트리의-지름-골드-2">트리의 지름 골드 2</h1>

<h2 id="문제">문제</h2>
<p>트리의 지름이란, 트리에서 임의의 두 점 사이의 거리 중 가장 긴 것을 말한다. 트리의 지름을 구하는 프로그램을 작성하시오.</p>

<h2 id="입력">입력</h2>
<p>트리가 입력으로 주어진다. 먼저 첫 번째 줄에서는 트리의 정점의 개수 V가 주어지고 (2 ≤ V ≤ 100,000)둘째 줄부터 V개의 줄에 걸쳐 간선의 정보가 다음과 같이 주어진다. 정점 번호는 1부터 V까지 매겨져 있다.</p>

<p>먼저 정점 번호가 주어지고, 이어서 연결된 간선의 정보를 의미하는 정수가 두 개씩 주어지는데, 하나는 정점번호, 다른 하나는 그 정점까지의 거리이다. 예를 들어 네 번째 줄의 경우 정점 3은 정점 1과 거리가 2인 간선으로 연결되어 있고, 정점 4와는 거리가 3인 간선으로 연결되어 있는 것을 보여준다. 각 줄의 마지막에는 -1이 입력으로 주어진다. 주어지는 거리는 모두 10,000 이하의 자연수이다.</p>

<h2 id="출력">출력</h2>
<p>첫째 줄에 트리의 지름을 출력한다.</p>

<h2 id="풀이">풀이</h2>
<p>이전에 풀었던 트리의 지름(1967 골드4) 문제와 유사하다. 다른 점은 입력 조건이 조금 더 까다롭고 풀이 방식은 동일하다.</p>

<p>int pair를 가지는 vector로 그래프를 저장한다.(인접그래프 방식)
아무 노드에서 dfs를 처리하면 가장 끝에 있는(가중치 순으로) 노드를 확인할 수 있다.</p>

<p>해당 노드를 전역으로 저장해놓았다가, 그 노드에서 dfs를 수행하면 전체 트리에 가장 먼 거리를 알 수 있다. (가중치 순으로 dfs가 진행되기 때문)</p>

<h2 id="코드">코드</h2>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">graph</span><span class="p">[</span><span class="mi">100001</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">visited</span><span class="p">[</span><span class="mi">100001</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">maxDis</span><span class="p">,</span> <span class="n">maxNode</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">init</span><span class="p">(){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100001</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">maxDis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">weight</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">maxDis</span> <span class="o">&lt;</span> <span class="n">weight</span><span class="p">){</span>
        <span class="n">maxDis</span> <span class="o">=</span> <span class="n">weight</span><span class="p">;</span>
        <span class="n">maxNode</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">graph</span><span class="p">[</span><span class="n">start</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">start</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">,</span> <span class="n">graph</span><span class="p">[</span><span class="n">start</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">second</span> <span class="o">+</span> <span class="n">weight</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>

    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span> 
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">weight</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">num</span> <span class="o">&gt;&gt;</span> <span class="n">index</span><span class="p">;</span>

        <span class="k">while</span><span class="p">(</span><span class="n">index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">weight</span><span class="p">;</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">num</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">weight</span><span class="p">));</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">weight</span><span class="p">));</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">index</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">init</span><span class="p">();</span>
    <span class="n">dfs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">init</span><span class="p">();</span>
    <span class="n">dfs</span><span class="p">(</span><span class="n">maxNode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">maxDis</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name>Hun</name></author><category term="PS" /><category term="DFS" /><summary type="html"><![CDATA[트리의 지름 골드 2]]></summary></entry></feed>