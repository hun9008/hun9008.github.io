<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.9.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2024-02-08T23:50:44+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">console.log(‘HUN’)</title><subtitle>A J.Y.Hun's Devlog</subtitle><author><name>Hun</name><email>younghune135@gmail.com</email></author><entry><title type="html">Bridging Domain Spaces for Unsupervised Domain Adaptation [논문]</title><link href="http://localhost:4000/2024/02/08/BridgingDomainSpacesForUnsupervisedDomainAdaptation/" rel="alternate" type="text/html" title="Bridging Domain Spaces for Unsupervised Domain Adaptation [논문]" /><published>2024-02-08T21:18:00+09:00</published><updated>2024-02-08T21:18:25+09:00</updated><id>http://localhost:4000/2024/02/08/BridgingDomainSpacesForUnsupervisedDomainAdaptation</id><content type="html" xml:base="http://localhost:4000/2024/02/08/BridgingDomainSpacesForUnsupervisedDomainAdaptation/"><![CDATA[<p>저자 : Wonjun Hwang</p>

<h1 id="1-introduction">1. Introduction</h1>
<p>최근 컴퓨터 비전 딥러닝 애플리케이션에서 상당한 개선을 보였지만, 대부분 지도학습이었다. 지도학습에는 데이터를 수입하는데 많은 비용이 들어 준지도(semi-supervised), 비지도(unsupervised)학습이 연구되었는데 이는 유사한 도메인에서의 학습이었다.</p>

<p><img src="/UDA_figure1.png" /></p>

<blockquote>
  <p>이전 UDA에서는 source와 target 도메인의 격차를 줄이기 위해 discriminator(판별자), MMD, JMMD 등을 사용했고 GAN 기반 DA가 사용되었다. 기본적으로 이는 source와 target간의 거리가 큰 경우는 고려되지 않는다.</p>
</blockquote>

<p>이 논문에서는 큰 도메인 불일치를 효율적으로 보상하기 위해 서로 상보적인 중간 증강 도메인을 구성한다. 이를 위해 Fixed ratio based mixup을 제안한다.</p>

<p>Fixed ratio based mixup은 source와 target사이 무작위성을 최소화하고 여러 중간 도메인을 생성한다.</p>
<blockquote>
  <p>예를들어 Augmented domain close to the source domain 은 레이블 정보는 있지만 target 도메인과 상관관계는 낮다.</p>

  <p>반면 Augmented domain close to the target domain은 라벨 정보는 부정확하지만 target domain과 유사성은 높다.</p>
</blockquote>

<p>이런 증강된 도메인에서 source와 target 도메인 사이를 연결하도록 서로 가르치는 보완모델을 훈련한다.
구체적으로, target 샘플에 대한 높은 신뢰도 예측을 기반으로 한 양방향 매칭을 도입해 중간 도메인을 target 도메인으로 연결시킨다.</p>

<p>또한 self-traning을 통해 성능을 향상시키기 위해, self-penalization을 적용한다.</p>

<p>또한 각 iteration마다 변화하는 특성을 적절히 부과하가 위해 각 미니배치의 신뢰분포에 의한 적응형 임계값을 사용한다.</p>

<p>마지막으로 서로 다른 증강된 모델의 발산을 막고자, source와 target 샘플의 비율이 동일한 증강 도메인을 사용해 일관성 정규화를 제안한다.</p>

<p>Office-31, Office-Home, VisDA에서 테스트를 수행했다.</p>

<h1 id="2-related-work">2. Related Work</h1>

<h1 id="3-proposed-methods">3. Proposed methods</h1>]]></content><author><name>Hun</name></author><category term="Paper" /><category term="Domain Adaptation" /><summary type="html"><![CDATA[저자 : Wonjun Hwang]]></summary></entry><entry><title type="html">백준 트리의 지름(1167) [c++]</title><link href="http://localhost:4000/2024/02/08/1167_TreeRadius/" rel="alternate" type="text/html" title="백준 트리의 지름(1167) [c++]" /><published>2024-02-08T20:00:00+09:00</published><updated>2024-02-08T20:08:25+09:00</updated><id>http://localhost:4000/2024/02/08/1167_TreeRadius</id><content type="html" xml:base="http://localhost:4000/2024/02/08/1167_TreeRadius/"><![CDATA[<h1 id="트리의-지름-골드-2">트리의 지름 골드 2</h1>

<h2 id="문제">문제</h2>
<p>트리의 지름이란, 트리에서 임의의 두 점 사이의 거리 중 가장 긴 것을 말한다. 트리의 지름을 구하는 프로그램을 작성하시오.</p>

<h2 id="입력">입력</h2>
<p>트리가 입력으로 주어진다. 먼저 첫 번째 줄에서는 트리의 정점의 개수 V가 주어지고 (2 ≤ V ≤ 100,000)둘째 줄부터 V개의 줄에 걸쳐 간선의 정보가 다음과 같이 주어진다. 정점 번호는 1부터 V까지 매겨져 있다.</p>

<p>먼저 정점 번호가 주어지고, 이어서 연결된 간선의 정보를 의미하는 정수가 두 개씩 주어지는데, 하나는 정점번호, 다른 하나는 그 정점까지의 거리이다. 예를 들어 네 번째 줄의 경우 정점 3은 정점 1과 거리가 2인 간선으로 연결되어 있고, 정점 4와는 거리가 3인 간선으로 연결되어 있는 것을 보여준다. 각 줄의 마지막에는 -1이 입력으로 주어진다. 주어지는 거리는 모두 10,000 이하의 자연수이다.</p>

<h2 id="출력">출력</h2>
<p>첫째 줄에 트리의 지름을 출력한다.</p>

<h2 id="풀이">풀이</h2>
<p>이전에 풀었던 트리의 지름(1967 골드4) 문제와 유사하다. 다른 점은 입력 조건이 조금 더 까다롭고 풀이 방식은 동일하다.</p>

<p>int pair를 가지는 vector로 그래프를 저장한다.(인접그래프 방식)
아무 노드에서 dfs를 처리하면 가장 끝에 있는(가중치 순으로) 노드를 확인할 수 있다.</p>

<p>해당 노드를 전역으로 저장해놓았다가, 그 노드에서 dfs를 수행하면 전체 트리에 가장 먼 거리를 알 수 있다. (가중치 순으로 dfs가 진행되기 때문)</p>

<h2 id="코드">코드</h2>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">graph</span><span class="p">[</span><span class="mi">100001</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">visited</span><span class="p">[</span><span class="mi">100001</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">maxDis</span><span class="p">,</span> <span class="n">maxNode</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">init</span><span class="p">(){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100001</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">maxDis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">weight</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">maxDis</span> <span class="o">&lt;</span> <span class="n">weight</span><span class="p">){</span>
        <span class="n">maxDis</span> <span class="o">=</span> <span class="n">weight</span><span class="p">;</span>
        <span class="n">maxNode</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">graph</span><span class="p">[</span><span class="n">start</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">start</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">,</span> <span class="n">graph</span><span class="p">[</span><span class="n">start</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">second</span> <span class="o">+</span> <span class="n">weight</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>

    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span> 
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">weight</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">num</span> <span class="o">&gt;&gt;</span> <span class="n">index</span><span class="p">;</span>

        <span class="k">while</span><span class="p">(</span><span class="n">index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">weight</span><span class="p">;</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">num</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">weight</span><span class="p">));</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">weight</span><span class="p">));</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">index</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">init</span><span class="p">();</span>
    <span class="n">dfs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">init</span><span class="p">();</span>
    <span class="n">dfs</span><span class="p">(</span><span class="n">maxNode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">maxDis</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name>Hun</name></author><category term="PS" /><category term="DFS" /><summary type="html"><![CDATA[트리의 지름 골드 2]]></summary></entry><entry><title type="html">백준 동전0 [c++]</title><link href="http://localhost:4000/2024/02/08/11047_coin0/" rel="alternate" type="text/html" title="백준 동전0 [c++]" /><published>2024-02-08T00:30:00+09:00</published><updated>2024-02-07T02:08:30+09:00</updated><id>http://localhost:4000/2024/02/08/11047_coin0</id><content type="html" xml:base="http://localhost:4000/2024/02/08/11047_coin0/"><![CDATA[<h1 id="동전0-실버-4">동전0 실버 4</h1>

<h2 id="문제">문제</h2>
<p>준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.</p>

<p>동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.</p>

<h2 id="입력">입력</h2>

<p>첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)</p>

<p>둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)</p>

<h2 id="출력">출력</h2>

<p>첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.</p>

<h2 id="풀이">풀이</h2>

<p>전처리: 입력 동전 단위가 오름차순으로 주어지니, 스택에 넣어 내림차순으로 바꿔 사용하기 편하게 바꿈.</p>

<ol>
  <li>주어진 금액을 큰 단위의 동전으로 나눠지면 나눈다.</li>
  <li>위 과정을 주어진 금액이 0이 될때까지, 혹은 동전 단위가 1이 될때까지 반복</li>
</ol>

<h2 id="코드">코드</h2>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stack&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">k</span> <span class="p">;</span>

    <span class="kt">int</span> <span class="n">coin</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">c_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">scoin</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">coin</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">scoin</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">coin</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> 
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">temp</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">scoin</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">scoin</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="n">temp</span><span class="p">){</span>
            <span class="n">c_count</span> <span class="o">+=</span> <span class="p">(</span><span class="n">k</span> <span class="o">/</span> <span class="n">temp</span><span class="p">);</span>
            <span class="n">k</span> <span class="o">-=</span> <span class="p">(</span><span class="n">k</span> <span class="o">/</span> <span class="n">temp</span><span class="p">)</span> <span class="o">*</span> <span class="n">temp</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c_count</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name>Hun</name></author><category term="PS" /><category term="greedy" /><summary type="html"><![CDATA[동전0 실버 4]]></summary></entry><entry><title type="html">백준 쉬운 계단수 [c++]</title><link href="http://localhost:4000/2024/02/07/10844_%EC%89%AC%EC%9A%B4%EA%B3%84%EB%8B%A8%EC%88%98/" rel="alternate" type="text/html" title="백준 쉬운 계단수 [c++]" /><published>2024-02-07T00:18:00+09:00</published><updated>2024-02-06T02:08:25+09:00</updated><id>http://localhost:4000/2024/02/07/10844_%EC%89%AC%EC%9A%B4%EA%B3%84%EB%8B%A8%EC%88%98</id><content type="html" xml:base="http://localhost:4000/2024/02/07/10844_%EC%89%AC%EC%9A%B4%EA%B3%84%EB%8B%A8%EC%88%98/"><![CDATA[<h1 id="쉬운계단수-실버1">쉬운계단수 실버1</h1>

<h2 id="문제">문제</h2>
<p>45656이란 수를 보자.</p>

<p>이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.</p>

<p>N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.</p>

<h2 id="입력">입력</h2>
<p>첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.</p>

<h2 id="출력">출력</h2>
<p>첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.</p>

<h1 id="풀이">풀이</h1>
<ul>
  <li>이전 자리수가 0일경우 다음 자리수에 1만 올 수 있고, 이전 자리수가 9일경우 다음 자리수에 8만 올 수 있다.</li>
  <li>반면 그 외 1~8까지는 각각 2개씩 올 수 있다.</li>
  <li>0~9까지 배열을 한 자리의 dp로 생각하고 해결.</li>
</ul>

<h1 id="코드">코드</h1>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="mi">102</span><span class="p">][</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="p">};</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="mi">1000000000</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">9</span><span class="p">){</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">8</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">9</span><span class="p">]</span> <span class="o">%</span> <span class="mi">1000000000</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span><span class="p">{</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">1000000000</span><span class="p">;</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">1000000000</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span> <span class="o">%</span> <span class="mi">1000000000</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h1 id="총평">총평</h1>
<ul>
  <li>1~3자리까지 트리로 그려보면 쉽게 해결가능.</li>
</ul>]]></content><author><name>Hun</name></author><category term="PS" /><category term="DP" /><summary type="html"><![CDATA[쉬운계단수 실버1]]></summary></entry><entry><title type="html">백준 카드 구매하기 [c++]</title><link href="http://localhost:4000/2024/02/07/11052_buyCard/" rel="alternate" type="text/html" title="백준 카드 구매하기 [c++]" /><published>2024-02-07T00:18:00+09:00</published><updated>2024-02-06T02:08:25+09:00</updated><id>http://localhost:4000/2024/02/07/11052_buyCard</id><content type="html" xml:base="http://localhost:4000/2024/02/07/11052_buyCard/"><![CDATA[<h1 id="11052-카드-구매하기-실버1">11052 카드 구매하기 실버1</h1>

<h2 id="문제">문제</h2>
<p>요즘 민규네 동네에서는 스타트링크에서 만든 PS카드를 모으는 것이 유행이다.</p>

<p>PS카드는 PS(Problem Solving)분야에서 유명한 사람들의 아이디와 얼굴이 적혀있는 카드이다. 각각의 카드에는 등급을 나타내는 색이 칠해져 있고, 다음과 같이 8가지가 있다.</p>

<p>전설카드
레드카드
오렌지카드
퍼플카드
블루카드
청록카드
그린카드
그레이카드
카드는 카드팩의 형태로만 구매할 수 있고, 카드팩의 종류는 카드 1개가 포함된 카드팩, 카드 2개가 포함된 카드팩, … 카드 N개가 포함된 카드팩과 같이 총 N가지가 존재한다.</p>

<p>민규는 카드의 개수가 적은 팩이더라도 가격이 비싸면 높은 등급의 카드가 많이 들어있을 것이라는 미신을 믿고 있다. 따라서, 민규는 돈을 최대한 많이 지불해서 카드 N개 구매하려고 한다. 카드가 i개 포함된 카드팩의 가격은 Pi원이다.</p>

<p>예를 들어, 카드팩이 총 4가지 종류가 있고, P1 = 1, P2 = 5, P3 = 6, P4 = 7인 경우에 민규가 카드 4개를 갖기 위해 지불해야 하는 금액의 최댓값은 10원이다. 2개 들어있는 카드팩을 2번 사면 된다.</p>

<p>P1 = 5, P2 = 2, P3 = 8, P4 = 10인 경우에는 카드가 1개 들어있는 카드팩을 4번 사면 20원이고, 이 경우가 민규가 지불해야 하는 금액의 최댓값이다.</p>

<p>마지막으로, P1 = 3, P2 = 5, P3 = 15, P4 = 16인 경우에는 3개 들어있는 카드팩과 1개 들어있는 카드팩을 구매해 18원을 지불하는 것이 최댓값이다.</p>

<p>카드 팩의 가격이 주어졌을 때, N개의 카드를 구매하기 위해 민규가 지불해야 하는 금액의 최댓값을 구하는 프로그램을 작성하시오. N개보다 많은 개수의 카드를 산 다음, 나머지 카드를 버려서 N개를 만드는 것은 불가능하다. 즉, 구매한 카드팩에 포함되어 있는 카드 개수의 합은 N과 같아야 한다.</p>

<h1 id="풀이">풀이</h1>
<ul>
  <li>dp에 Pi를 입력한다.</li>
  <li>카드를 i개 살때 최대인 금액을 dp로 생각한다.</li>
  <li>dp[2] = max(dp[2], dp[1]+dp[1])</li>
  <li>dp[3] = max(dp[3], dp[2]+dp[1])</li>
  <li>dp[4] = max(dp[4], dp[3]+dp[1], dp[2]+dp[2])</li>
  <li>dp[5] = max(dp[5], dp[4]+dp[1], dp[3]+dp[2])</li>
  <li>…</li>
  <li>보면 2,3,4,5,6,7,8,9 번째에 비교해야할 인자가 각각 2,2,3,3,4,4,5,5 개로 증가한다.</li>
  <li>개수에 맞게 temp배열에 저장한 뒤, sort해서 가장 큰 값을 찾았다.</li>
  <li>비교적 쉽게 풀림.</li>
</ul>

<h1 id="코드">코드</h1>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">tempNum</span> <span class="o">=</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">temp</span><span class="p">[</span><span class="n">tempNum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">tempNum</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">temp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">temp</span> <span class="o">+</span> <span class="n">tempNum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="c1">// for(int k = 0; k &lt; tempNum + 1; k++)</span>
        <span class="c1">// {</span>
        <span class="c1">//     cout &lt;&lt; temp[k] &lt;&lt; " ";</span>
        <span class="c1">// }</span>
        <span class="c1">// cout &lt;&lt; endl;</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">tempNum</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name>Hun</name></author><category term="PS" /><category term="DP" /><summary type="html"><![CDATA[11052 카드 구매하기 실버1]]></summary></entry><entry><title type="html">백준 가장 긴 증가하는 부분 수열 [c++]</title><link href="http://localhost:4000/2024/02/07/11053_longestSerial/" rel="alternate" type="text/html" title="백준 가장 긴 증가하는 부분 수열 [c++]" /><published>2024-02-07T00:18:00+09:00</published><updated>2024-02-06T02:08:25+09:00</updated><id>http://localhost:4000/2024/02/07/11053_longestSerial</id><content type="html" xml:base="http://localhost:4000/2024/02/07/11053_longestSerial/"><![CDATA[<h1 id="가장-긴-증가하는-부분-수열-실버2">가장 긴 증가하는 부분 수열 실버2</h1>

<h2 id="문제">문제</h2>
<p>수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.</p>

<p>예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.</p>

<h2 id="입력">입력</h2>
<p>첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.</p>

<p>둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)</p>

<h2 id="출력">출력</h2>
<p>첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.</p>

<h1 id="풀이">풀이</h1>
<ul>
  <li>처음에는 아래와 같이 그래프탐색으로 해결하려 했음.</li>
</ul>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">serial</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="n">queue</span> <span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">serial</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">max_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

        <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">max_count</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">){</span>
                <span class="n">max_count</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
            <span class="p">}</span>   
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="n">serial</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">serial</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span>
                    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">max_count</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<ul>
  <li>그런데 메모리 초과 남.</li>
  <li>이유를 생각해보니 N은 최대 1000이고 queue는 pair로 하나당 16바이트, 그럼 최악의 경우 1000! * 16byte의 메모리</li>
  <li>이미 1000!에서 메모리를 계산하는 의미가 없음.(졸라 큼)</li>
  <li>그래서 찾아보니 dp문제였음.</li>
  <li>dp[i] = max(dp[i],dp[j]+1) 로 문제의 예시로 살펴보면</li>
</ul>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>i = 0</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>i = 1</td>
      <td>1</td>
      <td>2</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>i = 2</td>
      <td>1</td>
      <td>2</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>i = 3</td>
      <td>1</td>
      <td>2</td>
      <td>1</td>
      <td>3</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>i = 4</td>
      <td>1</td>
      <td>2</td>
      <td>1</td>
      <td>3</td>
      <td>2</td>
      <td>1</td>
    </tr>
    <tr>
      <td>i = 5</td>
      <td>1</td>
      <td>2</td>
      <td>1</td>
      <td>3</td>
      <td>2</td>
      <td>4</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>이런식으로 dp로 해결가능.</li>
</ul>

<h1 id="코드">코드</h1>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">serial</span><span class="p">[</span><span class="mi">1001</span><span class="p">];</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">serial</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">max_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="mi">1001</span><span class="p">];</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">serial</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">serial</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">max_cnt</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max_cnt</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">max_cnt</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name>Hun</name></author><category term="PS" /><category term="LIS" /><category term="DP" /><summary type="html"><![CDATA[가장 긴 증가하는 부분 수열 실버2]]></summary></entry><entry><title type="html">백준 오르막 수 [c++]</title><link href="http://localhost:4000/2024/02/07/11057_risingNumber/" rel="alternate" type="text/html" title="백준 오르막 수 [c++]" /><published>2024-02-07T00:18:00+09:00</published><updated>2024-02-06T02:08:25+09:00</updated><id>http://localhost:4000/2024/02/07/11057_risingNumber</id><content type="html" xml:base="http://localhost:4000/2024/02/07/11057_risingNumber/"><![CDATA[<h1 id="오르막수-실버1">오르막수 실버1</h1>

<h2 id="문제">문제</h2>
<p>오르막 수는 수의 자리가 오름차순을 이루는 수를 말한다. 이때, 인접한 수가 같아도 오름차순으로 친다.</p>

<p>예를 들어, 2234와 3678, 11119는 오르막 수이지만, 2232, 3676, 91111은 오르막 수가 아니다.</p>

<p>수의 길이 N이 주어졌을 때, 오르막 수의 개수를 구하는 프로그램을 작성하시오. 수는 0으로 시작할 수 있다.</p>

<h1 id="문제-풀이">문제 풀이</h1>
<ul>
  <li>자리수 별로 생각해보았다.</li>
  <li>최고자리수의 수가 커질수록 가능한 경우의 수가 일정히 줄었다.</li>
  <li>ex</li>
</ul>

<table>
  <thead>
    <tr>
      <th>최고자리수</th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
      <th>8</th>
      <th>9</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1자리는</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>2자리는</td>
      <td>10</td>
      <td>9</td>
      <td>8</td>
      <td>7</td>
      <td>6</td>
      <td>5</td>
      <td>4</td>
      <td>3</td>
      <td>2</td>
      <td>1</td>
    </tr>
    <tr>
      <td>3자리는</td>
      <td>55</td>
      <td>45</td>
      <td>36</td>
      <td>28</td>
      <td>21</td>
      <td>15</td>
      <td>10</td>
      <td>6</td>
      <td>3</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>dp[i] 는 이전dp[i]~dp[9]까지의 합임을 알 수 있었다.</li>
</ul>

<h1 id="코드">코드</h1>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">%</span> <span class="mi">10007</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">%</span> <span class="mi">10007</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="p">}</span></code></pre></figure>

<h1 id="총평">총평</h1>
<ul>
  <li>10007로 나눈 나머지를 저장하는데 dp를 만들때 수행해주고,</li>
  <li>마지막 답을 낼때, dp[0]~dp[9]까지의 합을 한 후에도 수행해주어야 한다.</li>
</ul>]]></content><author><name>Hun</name></author><category term="PS" /><category term="DP" /><summary type="html"><![CDATA[오르막수 실버1]]></summary></entry><entry><title type="html">백준 트리의 부모 찾기 [c++]</title><link href="http://localhost:4000/2024/02/07/11725_ParentTree/" rel="alternate" type="text/html" title="백준 트리의 부모 찾기 [c++]" /><published>2024-02-07T00:18:00+09:00</published><updated>2024-02-06T02:08:25+09:00</updated><id>http://localhost:4000/2024/02/07/11725_ParentTree</id><content type="html" xml:base="http://localhost:4000/2024/02/07/11725_ParentTree/"><![CDATA[<h1 id="트리의-부모-찾기-실버2">트리의 부모 찾기 실버2</h1>

<h2 id="문제">문제</h2>
<p>루트 없는 트리가 주어진다. 이때, 트리의 루트를 1이라고 정했을 때, 각 노드의 부모를 구하는 프로그램을 작성하시오.</p>

<h2 id="입력">입력</h2>
<p>첫째 줄에 노드의 개수 N (2 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N-1개의 줄에 트리 상에서 연결된 두 정점이 주어진다.</p>

<h2 id="출력">출력</h2>
<p>첫째 줄부터 N-1개의 줄에 각 노드의 부모 노드 번호를 2번 노드부터 순서대로 출력한다.</p>

<h1 id="풀이">풀이</h1>
<ul>
  <li>bfs문제로 벡터로 인접트리구현 후 bfs돌면서 부모 표시. 부모 출력.</li>
  <li>주의할 점은 입출력이 많기에 stdio사용 &amp; ios_base::sync_with_studio(0); cin.tie(0)설정 필요.</li>
</ul>

<h1 id="코드">코드</h1>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tree</span><span class="p">[</span><span class="mi">100001</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">visited</span><span class="p">[</span><span class="mi">100001</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">parent</span><span class="p">[</span><span class="mi">100001</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">init</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100001</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// cout &lt;&lt; "init!" &lt;&lt; endl;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">bfs</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
    <span class="n">visited</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">child</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">n_size</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">child</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span><span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">parent</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
                <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">f</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">f</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">s</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">init</span><span class="p">();</span>
    <span class="n">bfs</span><span class="p">();</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>


<span class="p">}</span></code></pre></figure>]]></content><author><name>Hun</name></author><category term="PS" /><category term="BFS" /><summary type="html"><![CDATA[트리의 부모 찾기 실버2]]></summary></entry><entry><title type="html">백준 11726 2Xn 타일링 [c++]</title><link href="http://localhost:4000/2024/02/07/11726_2Xn_tiling/" rel="alternate" type="text/html" title="백준 11726 2Xn 타일링 [c++]" /><published>2024-02-07T00:18:00+09:00</published><updated>2024-02-06T02:08:25+09:00</updated><id>http://localhost:4000/2024/02/07/11726_2Xn_tiling</id><content type="html" xml:base="http://localhost:4000/2024/02/07/11726_2Xn_tiling/"><![CDATA[<h1 id="2xn-타일링-실버3">2Xn 타일링 실버3</h1>

<h2 id="문제">문제</h2>
<p>2×n 크기의 직사각형을 1×2, 2×1 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.</p>

<p>아래 그림은 2×5 크기의 직사각형을 채운 한 가지 방법의 예이다.</p>

<h1 id="문제-풀이">문제 풀이</h1>
<p>1~5까지 그려보니 피보나치임을 알 수 있었다. 그래서 dp로 풀었다.
금방 풀었다. 그런데 10007로 나눈 나머지를 출력해야 하는데 dp를 계산할 때 적용해도 동일한 결과가 나옴을 알 수 있었다.</p>
<ul>
  <li>modulo 특징 적용!</li>
</ul>

<h1 id="코드">코드</h1>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">tile</span><span class="p">[</span><span class="mi">1002</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">dp</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">tile</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">tile</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">tile</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tile</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">tile</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">%</span> <span class="mi">10007</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">tile</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">dp</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tile</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h1 id="총평">총평</h1>
<ul>
  <li>Easy.</li>
  <li>but 조건 잘 읽자.</li>
</ul>]]></content><author><name>Hun</name></author><category term="PS" /><category term="DP" /><summary type="html"><![CDATA[2Xn 타일링 실버3]]></summary></entry><entry><title type="html">백준 2Xn 타일링2 [c++]</title><link href="http://localhost:4000/2024/02/07/11727_2Xn_tiling_2/" rel="alternate" type="text/html" title="백준 2Xn 타일링2 [c++]" /><published>2024-02-07T00:18:00+09:00</published><updated>2024-02-06T02:08:25+09:00</updated><id>http://localhost:4000/2024/02/07/11727_2Xn_tiling_2</id><content type="html" xml:base="http://localhost:4000/2024/02/07/11727_2Xn_tiling_2/"><![CDATA[<h1 id="2xn-타일링2-실버3">2Xn 타일링2 실버3</h1>

<h2 id="문제">문제</h2>
<p>2×n 직사각형을 1×2, 2×1과 2×2 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.</p>

<p>아래 그림은 2×17 직사각형을 채운 한가지 예이다.</p>

<h2 id="입력">입력</h2>
<p>첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)</p>

<h2 id="출력">출력</h2>
<p>첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.</p>

<h1 id="풀이">풀이</h1>
<ul>
  <li>2Xn 타일링과 비슷하나 2*2타일이 생겼다.</li>
  <li>유사한 dp문제라 생각하고 n = 5까지 작성해봄.</li>
  <li>dp[i] = dp[i-1] + dp[i-2]*2라는 식 나옴.</li>
  <li>Done.3</li>
</ul>

<h1 id="코드">코드</h1>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="mi">1002</span><span class="p">];</span>

    <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10007</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>


    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name>Hun</name></author><category term="PS" /><category term="DP" /><summary type="html"><![CDATA[2Xn 타일링2 실버3]]></summary></entry></feed>